## 一.函数增强

### 1.1函数对象的属性

- name
- length

### 1.2arguments转成数组

- 三种方式

  - 新建数组将args的值push进去

    ```js
    var newnums = []
                for (const aa of arguments) {
                    newnums.push(aa)
                }
                for (const aa of newnums) {
                    console.log(aa)
                }
    ```

  - 直接使用现成的函数

    ```js
    var newnums = Array.from(arguments)
                console.log(newnums)
                var newnum2 = [...arguments]
                console.log(newnum2)
    ```

  - 使用slice方法转化

    ```js
     var nums = [].slice.apply(arguments)
     var nnns = Array.prototype.slice.apply(arguments)
                //两种方法一样
                console.log(nnns)
                console.log(nums)  
    ```

    

- 箭头函数不绑定arguments

- 箭头函数进行嵌套的函数能够找到相应的args

### 1.3剩余参数rest

- 样式

  ```js
  function foo(num1,num2,...othernums){
              console.log(arguments)
  
              //argument不是
              //本身就是数组
              console.log(othernums)//拿到剩余的参数
          }
  ```

  

- args数组

  ```js
  function bar(...args){
              console.log(args)
          }
          bar(1,1,1,1,1,1)
  ```

  

### 1.4纯函数的使用

- 纯函数的概念

  - 确定的输入一定产生确定的输出
  - 执行过程中不能产生副作用

  ```js
  function sum(num1,num2){
              return num1+num2
          }
  ```

  ```
   //不是纯函数，产生副作用，改变对应的对象
          function print(info){
              console.log(info.name,info.age,info.message)
              info.flag = "已经打印结束"
          }
          
          var obj = {
              name : "why",
              age  : 18,
              message : "hhhh"
          }
          print(obj)
  ```

  

- 实际开发中的应用

  - react/redux

- 没有必要每一个函数都是纯函数

### 1.5函数柯里化的过程

- 什么是柯里化的过程

  将一个需要多个参数的函数转换成为一系列只接受单个参数的函数，每次调用，返回新的函数，直到所有的函数都被提供，返回最终的计算结果

  ```js
  function foo1(x,y,z){
              console.log(x + y + z)
          }
          // foo(1,2,3)
          
          //foo不是柯里化的函数
  
          //从上面转化成下面就是函数柯里化的过程
          function foo2(x){
              return function(y){
                  return function(z){
                      console.log(x + y + z)
                  }
              }
          }
  ```

  

- 案例

- 柯里化的优势

  - 职责单一
  - 参数的复用

- 自动柯里化的函数封装

### 1.6组合函数的使用

- 将多个函数组合在一起，一起调用

- 封装组合函数

  ```js
  function hyCurrying(fn){
              function curryFn(...args){
                  //两类操作
                  //1.继续返回新的函数
  
                  if(args.length >= fn.length){
                      //执行第二类操作 够用直接返回
                      return fn.apply(this,args)
                  }
                  else{
                      //执行第一类操作 减去最开头的然后直接使用
                      return function(...newargs){
                          return curryFn.apply(this,args.concat(newargs))
                      }
                  }
              }
              return curryFn // 返回柯里化的函数
          }
  ```

  

## 二.额外知识

### 2.1with（很少见到）

多加了作用域链

```js
 var obj = {
            message : "hello"
        }

        with(obj){//多加了一层obj作用域，扩展作用域链
            console.log(message)
        }
```



### 2.2.eval（很少见到）

可以通过``运行代码

```js
 var code = `var name = "huuyii";
                    console.log(name)`
        eval(code)//可以直接运行代码 将最后一行代码作为返回结果

        //1。eval代码的可读性非常差
        //2.eval是一个字符串，那么有可能在执行种被更改，有风险
        //3.eval执行必须经过js解释器，不能被js引擎优化
```



### 2.3严格模式

- 什么是严格模式

​		ES5引入的一种js模式，对代码的执行环境进行了限制和增强，帮助更规范，安全的编写代码

- 如何开启严格模式

  - 文件开启

    js开头加上"use strict"

  - 函数开启

    在函数的开头加上"use strict"

- 严格模式的限制

  - 例子

    ```js
    <script>
            "use strict"
    
            //1.不会意外的创建全局变量
            // function foo(){
            //     message = "Hello world"
            // }
    
            // foo()
            // console.log(message)
            //开启严格模式就会报错
    
            //2.发现静默错误
            var obj = {
                name : "why"
            }
    
            //这样就不会报错
            Object.defineProperty(obj,"name",{
                writable : false,//不能进行修改
                configurable : false//不能进行删除
            })
            // obj.name = "kobe"
            // delete obj.name
            console.log(obj.name)
    
            //4，不能使用0开头
            console.log(0o123)
    
            //5.with不能使用
    
            //eval函数不能为上层创建变量
            //eval需要单独加严格模式
            // eval(`var message = "hello"`)
            // console.log(message)
    
            //6。严格模式下，this不会传话成为对象类型
            function foo(num){
                console.log(this)
            }
        </script>
    ```

    

## 三.对象的增强

### 3.1属性描述符

```js
 <script>
        obj = {
            name : "huuyii",
            age  : 18
        }

        obj.name = " "
        delete obj.name
        console.log(obj.name)
    
        //对对象中的某些属性进行限制

    </script>
```



### 3.2数据属性描述符

- configureable 不能进行删除和修改
- enumerable 不能通过 forin Object.keys拿到
- writable 只能读取不能写入
- value 返回固定的值

### 3.3存储属性描述符

- configuralbe

- enumerable

- get 精确的控制两个属性

  ```
  get : function(){
                  return _name
              }
  ```

   

- set

  ```
  set : function(value){
                  console.log("set函数被调用",value)
                  _name = value
              },
  ```

  

### 3.4定义多个属性描述符（ES5之后出现）

```js
 Object.defineProperties(obj,{
            name : {
                configurable : true,
                enumerable : true,
                writable : false,
            },
            age : {
                configurable : true,
                enumerable : true,
            }
        })
```



### 3.5额外方法的补充

- getOwnPropertyDescriptor
- preventExtensions
- seal
- freeze

```js
	<script>
        var obj = {
            name : "why",
            age : 18
        }
        //获取对象属性描述符
        console.log(Object.getOwnPropertyDescriptor(obj,"name"))
        console.log(Object.getOwnPropertyDescriptors(obj))
        

        //禁止对象的扩展
        Object.preventExtensions(obj)
        // obj.address = "chengdu"


        //密封对象，不允许配置和删除属性 ： seal
        //调用preventExtensions
        //configure ： false
        Object.seal(obj)
        

        //冻结对象 ： 不能够进行写入 wrirteable : false
        Object.freeze(obj)
        
    </script>
```

