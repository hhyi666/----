## 一.原型的理解

### 1.1对象的原型

- 任何对象都有自己的原型（隐式原型）
- 作用：在当前对象查找某一个属性的时候，会在原型上查找
- 获取原型
  - `__proto__`
  - `object.getPrototypeOf(obj)`

### 1.2函数的原型

- 任何一个函数（非箭头）都有自己的原型`prototype`
- 获取原型
  - `prototype`
- 作用：
  - 当通过new操作符调用函数的时候，创建一个新对象
  - 这个对象的隐式原型会指向这个函数的显式原型
  - `obj.__proto__ = F.prototype`

### 1.3构造函数的正确写法

```js
funtion Person(name,age){
	this.name = name
	this.age = age
}
//对于有子对象需要这个函数，直接在原型中设置这个函数
Person.prototype.running = funtion(){
	clg("~~running")		
}
```

### 1.4显式原型上的constructor

constructor默认指向对象的本身

### 1.5重写显式原型

在需要多个函数的时候，直接重写函数原型

！！！记得在最后加上函数本身自己的 constructor

使用defineProperty + construct

```js
Person.prototype = {
            message : "jjj",
            info : "kkk",
            running : function(){},
            // constructor : Person  //这样写就能够访问到constructor
            //!!!!!!!!最后记得加上原来函数的constructor
        }
        Object.defineProperty(Person,"constructor",{value : Person})//这样加上就不会通过keys访问到
        console.log(Object.keys(Person.prototype))
```

## 二.ES5中的继承

### 2.1面向对象的三大特性

- 封装
- 继承
- 多态
- 抽象

### 2.2原项链的概念

- 原型对象和原型对象之间可以形成链条沿着我们的链查找对应的属性

### 2.3原型实现继承

逻辑：

1. 创建新对象
2. 让新对象的隐式原型指向这个函数的显式原型
3. 这个对象赋值给子类的显式原型

```js
funtion Person(){}
funtion Student(){}

Student.prototype = new Person()
```

### 2.4借用构造函数

```
funtion Student(){
	Person(this,name...)//将person的变量传进来
}
```

### 2.5原型式/寄生式思想

### 2.6寄生组合式寄生

```js
funtion createObject(o){
	funtion F(){}
	F.prototype = o
	return new F()
}
funtion inherit(subtype,supertype){
	//方法1：
	Object.prototype = createObject(supertype.prototype)
	//方法2：
	subtype.prototype.__proto__ = supertype.prototype
	//方法3：
	Object.setPrototypeOf(subtype.prototype,supertype.prototype)
	
	//记得将自己的原来的constructor加上
	Object.defineProperty(subtype.prototype,"constructor",{
		enumerable : false
		configure : true
		writeable : false
		value : subtype
	})
}

funtion Person(){}
funtion Student(){}

inherit(Student,Person)//进行继承

```

### 2.7Object是最终的父类

### 2.8对象判断方法补充

- hasOwnProperty//判断某个属性是不是在自己的原型上

  ```
  var info = createObject(obj)
          info.address = "china"
          info.intro = "66666"
  
          console.log(info.address)
          console.log(info)
  
          //判断是不是在自己的原型上
          console.log(info.hasOwnProperty("name"))
          console.log(info.hasOwnProperty("address"))
  ```

  

- in / forin 找到key

  ```
  //in操作符
          //检查是否在原型上
          console.log("name" in info)
          //for in 都会遍历到 但有的不能被访问
          for(var key in info){
              console.log(key)
          }
  ```

  

- instance of 

  ```
  //instanceof
          function Person(){}
          function Student(){}
          
          inherit(Student,Person)
  
  
          //stu实例（iinstance）对象
          //stu 是 Student 的实例
          //找原型链 判断是否在原型链上
          var stu = new Student()
          console.log(stu instanceof Student)
          console.log(stu instanceof Person)
  ```

  

- isPrototypeOf

  ```
  //isPrototypeOf判断是否是stu的原型 和instance的反着来
          console.log(Student.prototype.isPrototypeOf(stu))
          console.log(obj.isPrototypeOf(stu))
  ```

  

### 思考

1. 什么是原型，原型链
   原型 ： 每个对象都有的内部属性可以通过`__proto__`或者prototype进行访问，引擎一开始会在自己的对象原型中寻找，没找到会根据原型链进行寻找，最找找到最顶端
   原型链：每个对象都有自己的原型，原型又有自己的原型，直到null，这样形成新的链式结构

2. 如何通过原型链实现继承
   即将子类的**构造函数**的原型设置成为父类的一个实例

   ```js
   // 将子类构造函数的原型设置为父类的一个实例
   Dog.prototype = new Animal('Generic Dog');
   
   // 在子类原型上添加特有的方法
   Dog.prototype.bark = function() {
       console.log(`${this.name} barks.`);
   };
   ```


   组合继承：继承原型链继承和构造函数继承的优点，继承父类的属性方法又在子类重新定义父类的属性

   ```js
   function Person(name,age,height,address){
               this.name = name
               this.age = age
               this.height = height
               this.address = address
           }
   
           Person.prototype.running = function(){
               console.log("running")
           }
           Person.prototype.eating = function(){
               console.log("eating")
           }
           
           //自己没有的继承父亲
           function Student(name,age,height,address,sno,score){
   
               //ES6之前常用的组合借用继承
               //重点： 借用构造函数继承
               //让this绑定stu对象
               Person.call(this,name,age,height,address)
               //构造函数会调用两次
   
               this.sno = sno
               this.score = score
           }
   //之后可以在子类中添加方法
           
   ```

   寄生组合式构造

   ```js
   <script>
           var obj = {
               name : "why",
               age : 18
           }
   
           function createObject(o){
               function F(){}
               F.prototype = o
               return new F()
           }
   
           //寄生式函数
           function createInfo(o,name,age,height){
               var newObj = createObject(o)
               newObj.name = name
               newObj.age = age
               newObj.height = height
               return newObj
           }
   
           // var info = {}
           // info.__proto__ = obj//直接在obj里面寻找 不能加__proto__这样就在obj的原型里面寻找
           // console.log(info.name)
       
           var info1 = createInfo(obj,"aaa",18,1.88)
           console.log(info1)
       </script>
   
   
   //函数原型
   function createObject(o){
       function F(){}
       F.prototype = o
       return new F()
   }
   //子类和父类函数
   function inherit(Subtype,Supertype){
   
       //方法1；
       Subtype.prototype = createObject(Supertype.prototype)
       Object.defineProperty(Subtype.prototype,"constructor",{
           enumerable : false,
           configurable : true,
           writable : true,
           value : Subtype
       })
       
       //方法2；
       Subtype.prototype.__proto__ = Supertype.prototype
   
   
       //方法3：
       Object.setPrototypeOf(Subtype.prototype,Supertype.prototype)
   }
   
   ```

   

3. 继承优缺点
   优点：减少代码复用 增强维护性 多态性的基础
   缺点：设计混乱 缺乏灵活性 

4. 最终实现ES5继承的方案

   ```js
   funtion createObject(o){
   	funtion F(o){}
   	F.prototype = o
   	return new F()
   }
   funtion inherit(subtype,supertype){
   	subtype.prototype = createObject(supertype.prototype)
   	Object.defineProperty(Subtype.prototype,"constructor",{
           enumerable : false,
           configurable : true,
           writable : true,
           value : Subtype
       })
       
       //方法2；
       Subtype.prototype.__proto__ = Supertype.prototype
   
   
       //方法3：
       Object.setPrototypeOf(Subtype.prototype,Supertype.prototype)
       
   }
   ```

   