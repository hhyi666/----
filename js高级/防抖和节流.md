## 一.防抖基本使用

### 1.1认识防抖（debounce）

每一次都向浏览器发送网络请求，是很消耗资源的，所以我们使用防抖延长发送的时间
等到不在进行输入的时候就发送网络请求
防抖能够使得我们在发送网络请求的时候，如果一段时间内不在改变，就发送网络请求
时间触发ns后再执行回调返回 如果这ns内又被触发，则重新计时
防止一段时间被频繁的触发

- 搭建案例

  ```js
  const inputEl = doucument.qs("input")
  let index = 1
  inputEl.oninput = _.debounce(function(){
     	console.log(`发送网络请求${index++}`,this.value)
  },1000)
  ```

  

### 1.2underscore实现防抖

- 通过CDN引入文件

  ```js
  const inputEl = doucument.qs("input")
  let index = 1
  inputEl.oninput = _.debounce(function(){
     	console.log(`发送网络请求${index++}`,this.value)
  },1000)
  ```

  
- _.debounce(fn,2000)改变发送网络请求的时间缓冲 代码和上面的一样

### 1.3防抖的实现

- 基本的实现

  ```js
          function hydebounce(fn,delay){
              let timer = null
              const _debounce = function(...args){
                  if(timer) clearTimeout(timer)
                  timer = setTimeout(() => {
                      fn.apply(this,args)
                      timer = null 
                  },delay)
              }
              return _debounce 
          }
          const inputEl = document.querySelector("input")
          let counter = 1
          //这里其实是可以往里面传入值的  传参能够调用再次使用
          inputEl.oninput = hydebounce(function(event){
              console.log(`发送请求${counter++}`,this.value) //this绑定的是window 
              
          },1000)
  
  ```

  

- this和参数的绑定

  ```js
          function hydebounce(fn,delay){
              let timer = null
              const _debounce = function(...args){
                  if(timer) clearTimeout(timer)
                  timer = setTimeout(() => {
                      fn.apply(this,args) //这里使用就能够将this绑定到input的身上
                      timer = null 
                  },delay)
              }
              return _debounce 
          }
          const inputEl = document.querySelector("input")
          let counter = 1
          //这里其实是可以往里面传入值的  传参能够调用再次使用
          inputEl.oninput = hydebounce(function(event){
              console.log(`发送请求${counter++}`,this.value) //this绑定的是window 
              
          },1000)
  
  ```

  

- 立即执行

  ```js
          function hydebounce(fn,delay,immediate = false){//默认的立即执行是false的
              let timer = null
              let isInvoke = false
              const _debounce = function(...args){
                  if(timer) clearTimeout(timer)
                  
                 	if(immediate && !isInvoke){
                    	fn.apply(this,args)
                      isInvoke = true
                      return
                  }
                  
                  timer = setTimeout(() => {
                      fn.apply(this,args) //这里使用就能够将this绑定到input的身上
                      timer = null 
                  },delay)
              }
              return _debounce 
          }
          const inputEl = document.querySelector("input")
          let counter = 1
          //这里其实是可以往里面传入值的  传参能够调用再次使用
          inputEl.oninput = hydebounce(function(event){
              console.log(`发送请求${counter++}`,this.value) //this绑定的是window 
              
          },1000)
  
  ```

  

- 取消功能

  ```js
          function hydebounce(fn,delay,immediate = false){//默认的立即执行是false的
              let timer = null
              let isInvoke = false
              const _debounce = function(...args){
                  if(timer) clearTimeout(timer)
                  
                 	if(immediate && !isInvoke){
                    	fn.apply(this,args)
                      isInvoke = true
                      return
                  }
                  
                  timer = setTimeout(() => {
                      fn.apply(this,args) //这里使用就能够将this绑定到input的身上
                      timer = null 
                  },delay)
              }
              
              //这里给_debounce 添加对象用来取消操作
              _debounce .cancel = function(){
                  if(timer)clearTimeout(timer)
              }
              
              return _debounce 
          }
          const inputEl = document.querySelector("input")
          let counter = 1
          //这里其实是可以往里面传入值的  传参能够调用再次使用
          inputEl.oninput = hydebounce(function(event){
              console.log(`发送请求${counter++}`,this.value) //this绑定的是window 
              
          },1000)
  
  ```

  

- 返回值
  想要有返回值
  可以使用callback函数回调出来 或者使用Promise进行回调
  then就能拿到对应的值

  ```js
          function hydebounce(fn,delay,immediate = false){//默认的立即执行是false的
              let timer = null
              let isInvoke = false
              const _debounce = function(...args){
                  if(timer) clearTimeout(timer)
               
                 	if(immediate && !isInvoke){
                    	fn.apply(this,args)
                      isInvoke = true
                      return
                  }
                  
                  timer = setTimeout(() => {
                      fn.apply(this,args) //这里使用就能够将this绑定到input的身上
                      timer = null 
                  },delay)
              }
              
              //这里给_debounce 添加对象用来取消操作
              _debounce .cancel = function(){
                  if(timer)clearTimeout(timer)
              }
              
              return _debounce 
          }
          const inputEl = document.querySelector("input")
          let counter = 1
          //这里其实是可以往里面传入值的  传参能够调用再次使用
          const res = hydebounce(function(event)){
  			console.log(`发送请求${counter++}`,this.value)
          })
  
  
  ```

  

### 

## 二节流基本使用

### 2.1认识节流（throttle）

规定的单位时间内，只能触发一次函数，如果这个单位时间能够触发多次函数，只有一次生效
间隔时间中执行函，都是防止一段时间被频繁的触发

### 2.2节流的实现

- 基本实现

  ```js
  function hythrottle(fn,interval){
  	let startTime = 0
  	const _throttle = {
  		const nowTime = new Date().getTime()
  		const waitTime = interval-(nowTime - startTime)
  		
  		if(waitTime <= 0){ 
  			fn.apply(this)
  			starTime = nowTime
  		}
  	}
  	return _throttle
  }
  
  let counter = 1
  inputEl.oninput = hythrottle(function(){
      console.log(`发送网络请求：${counter++}`,this.value)
  },3000) //每三秒进行触发
  ```

  

- this和参数的绑定

  ```js
  function hythrottle(fn,interval){
  	let startTime = 0
  	const _throttle = {
  		const nowTime = new Date().getTime()
  		const waitTime = interval-(nowTime - startTime)
  		
  		if(waitTime <= 0){ 
  			fn.apply(this) //这里记得this的绑定
  			starTime = nowTime
  		}
  	}
  	return _throttle
  }
  
  let counter = 1
  inputEl.oninput = hythrottle(function(){
      console.log(`发送网络请求：${counter++}`,this.value)
  },3000) //每三秒进行触发
  ```

  

- 立即执行

  ```js
  function hythrottle(fn,interval,immediate = true){//默认立即执行是true
  	let startTime = 0
  	const _throttle = {
  		const nowTime = new Date().getTime()
  		if(!immediate && startTime === 0){
              startTime = nowTime //就不是立即执行
          }
      	const waitTime = interval-(nowTime - startTime)
  		
          
  		if(waitTime <= 0){ 
  			fn.apply(this) //这里记得this的绑定
  			starTime = nowTime
  		}
  	}
  	return _throttle
  }
  
  let counter = 1
  inputEl.oninput = hythrottle(function(){
      console.log(`发送网络请求：${counter++}`,this.value)
  },3000) //每三秒进行触发
  ```

  

- 尾部执行

  ```js
  function hythrottle(fn,interval,immediate = true,tailing = true){//默认立即执行是true
  	let startTime = 0
  	const _throttle = {
  		const nowTime = new Date().getTime()
  		if(!immediate && startTime === 0){
              startTime = nowTime //就不是立即执行
          }
      	const waitTime = interval-(nowTime - startTime)
  		
          
  		if(waitTime <= 0){ 
  			fn.apply(this) //这里记得this的绑定
  			starTime = nowTime
  		}
  	}
  
  	if(tailing && !timer){
  		timer = setTime(() => {
              fn.apply(this,args)
              startTime = new Date().gettime()
              timer = null
          },waitTime)
      }
  	return _throttle
  }
  
  let counter = 1
  inputEl.oninput = hythrottle(function(){
      console.log(`发送网络请求：${counter++}`,this.value)
  },3000) //每三秒进行触发
  ```

  

- 取消功能

  ```
  //和上面的差不多就是加上cancel对象
  ```

  

- 返回值
  就是加上Promise进行返回

  ```js
          function hythrottle(fn, interval, { leading = true, trailing = true } = {}) {
              let startTime = 0
              let timer = null
              const _throttle = function (...args) { //可以传入参数
  
                  return new Promise((resolve, reject) => {
                      try {
                          const nowTime = new Date().getTime() //现在时间会非常大
  
                          //1.对第一次立即执行进行控制,只有第一次 不需要立即执行
                          if (!leading && startTime === 0) {
                              startTime = nowTime
                          }
                          const waitTime = interval - (nowTime - startTime) //第一次立即执行 这个是直接就是负值
  
                          if (waitTime <= 0) {
                              if (timer) clearTimeout(timer) // 防止下面和这里同时执行
                              const res = fn.apply(this, args) //使用apply进行绑定\
                              resolve(res)
                              startTime = nowTime
                              timer = null
                              return
                          }
  
                          //是否需要执行尾部 有定时器就不需要再次开启
                          if (trailing && !timer) {
                              timer = setTimeout(() => {
                                  const res = fn.apply(this, args)
                                  resolve(res)
                                  startTime = new Date().getTime() //这里要对最新时间进行赋值
                                  timer = null
                              }, waitTime);
                          }
                      } catch (error) {
                          reject(error)
                      }
                  })
  
              }
  
              _throttle.cancel = function () {
                  if (timer) clearTimeout(timer)
                  startTime = 0
                  timer = null
              }
              return _throttle
          }
  
  
          let counter = 1
          const throttleFn = hythrottle(function (event) {
              console.log(`发送网络请求：${counter++}`, this.value, event)
              return "运行成功 " //这个就是return的值，再resolve的时候会被传出来 调用的时候才会后才能出来
          }, 3000, { trailing: true }) //每三秒进行触发
          // inputEl.oninput = throttleFn
  
          //想要获取到返回值，就使用callback进行回调，或者=使用Promise resolve进行返回
          throttleFn("huuyii").then(res => console.log(res))
  ```

  





