## 一.原型关系图

- function Person(){}
- function Object(){}
- function Function(){}

![image-20250509170148096](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250509170148096.png)

## 二.ES6类的使用

### 2.1class定义类

1. 定义类 相当于定义了一个构造函数。属性，方法是prototype上的
2. new进行创建
   1. 创建一个空对象
   2. 将这个对象的proto绑定到prototypr上面
   3. 执行构造函数，this绑定到构造函数上面
   4. 如果构造函数返回一个对象，这个对象是new表达值的返回值；否则返回新创建的对象

### 2.2class类中的内容

- constructor方法

  - 表示自己函数的本身

- 实例方法
  创建的实例方法实际上是放在prototype上的

  ```js
  class Person{
              //1.类中的构造函数
              //通过new关键字调用Person函数时默认调用class中的constructor方法
              //固定写法
              constructor(name,age){
                  //this赋值给新对象
                  this.name = name
                  this.age = age
              }
  
              //2.实例方法
              //本质放在prototype上面
              running(){
                  console.log(this.name,"running")
              }
              eating(){
                  console.log("eating")
              }
          }
  ```

  

- 访问器方法

  - 对象访问器方法

    - 方案一：
      在外面使用defineProperty进行设置

      描述符直接进行访问 像 set get等描述符

      ```js
      //方式一：描述符
              var obj = {
                  name : "huuyii"
                  
              }
      
              //用来监听访问什么时候访问什么时候设置新的值
              Object.defineProperty(obj,"name",{
                  configurable : true,
                  enumerable : true,
                  set : function(){
                      
                  },
                  get : function(){
      
                  }
              })
      ```

    - 方案二：
      直接在对象的里面定义访问器 后面直接进行访问

      ```js
      //方式二 ： 直接在对象里面定义访问器
              //可以直接访问
              var obj = {
                  _name : "why",
      
                  //setter方法 //可以监听访问和更改的过程
                  set name(value){
                      this._name = value
                  },
                  get name(){
                      return this._name
                  }
              }
      ```

  - 类的访问器

    - 直接在类里面进行设置就行
      通过返回直接拿到

      ```js
      class Person{
                  //约定： 下划线开头的属性和方法不在外界进行访问
                  constructor(name,age){
                      this._name = name
                      this._age = age
                  }
                  set name(name){
                      this._name = name
                  }
      
                  get name(){
                      return this._name
                  }
              }
              var p1 = new Person("huuyii",12)
      
              //通过访问器进行修改name访问name
              p1.name = "aaa"
              console.log(p1.name)//这样的访问时通过setter进行访问
      
      
              //应用场景
              class Rectangle{
                  constructor(x,y,weight,height){
                      this.x = x
                      this.y = y
                      this.weight = weight
                      this.height = height
                  }
                  
                  get position(){
                      return {x:this.x,y:this.y}
                  }
      
                  get size(){
                      return {x:this.weight,y:this.height}
                  }
              }
              var rect1 = new Rectangle(10,20,100,200)
              console.log(rect1.position)
              console.log(rect1.size)
      ```

      

- 静态方法（static进行编写）

  ```js
  var names = ["aaa","vvv","ddd","ooo"]
          class Person{
  
              constructor(name,age){
                  this.name = name
                  this.age = age
              }
              //实例方法 放在显式原型上面
              running(){}
              eating(){}
  
              //类方法（静态方法） //放在对象上面
              static randomPerson(){
                  console.log(this) //Person调用的
                  var randomName = names[Math.floor(Math.random() * names.length)]
                  return new this(randomName,Math.floor(Math.random() * 100))
              }
          }
  
          var p1 = new Person()
          p1.running()
          var randomPerson = Person.randomPerson()
          console.log(randomPerson)
  ```

  

### 2.3class的extends继承

- extends关键字
- super关键字
  - 方案一：构造方法super（）
    - 一定在使用this之前以及返回对象之前先调用super
    - 构造函数的首行
  - 方案二：实例方法super.method()
  - 方案三：静态方法super.staticMethod()

### 2.4继承自内置类

- 对内置类进行扩展

- Array.prototype.xxx

  ```js
  //1.创建内置类进行扩展
          //使用内置类进行使用
          class HuuArray extends Array{
  
              get lastItem(){
                  return this[this.length-1]
              }
              get firstItem(){
                  return this[0]
              }
          }
  
          var arr = new HuuArray(10,20,30)
          //拓展可以自己写函数方法
          console.log(arr.lastItem)
          console.log(arr.firstItem)
  
          //2.直接对Array进行扩展
          Array.prototype.lastItem = function(){
              return this[this.length-1]
          }
          //直接对显式原型进行更改
  
          //函数的call aooly bind方法 -> Funtion prototype
  ```

### 2.5类的混入Mixin

​	子类想要继承自多个父类需要设置多个函数实现多继承

```js
function mixinAnimal(Baseclass){
            return class extends Baseclass{
                running(){console.log("running")}
            }
        }

        function mixinRunner(Baseclass){
            return class extends Baseclass{
                flying(){console.log("flying")}
            }
        }

        class Bird{
            eating(){
                console.log("eating")
            }
        }
        //实现多继承的方法
        var NewBird = mixinAnimal(mixinRunner(Bird))
        //多层继承，来增加新方法
        var bird = new NewBird()
        bird.flying()
        bird.eating()
```



## 三.babel ES6转换ES5源码

### 3.1只写一个class的源码

- ES6直接创建

  ```js
  class Person{}
  ```

- ES5创建非常麻烦 主要是原型的属性和方法之间的转换

  ```js
  "use strict";
  
          function _instanceof(n, e) { return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](n) : n instanceof e; }
          function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
          function _classCallCheck(a, n) { if (!_instanceof(a, n)) throw new TypeError("Cannot call a class as a function"); }
          function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
          function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
          function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
          function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
          var Person = /*#__PURE__*/function () {
              function Person(name, age) {
                  _classCallCheck(this, Person);
                  this.name = name;
                  this.age = age;
              }
              return _createClass(Person, [{
                  key: "running",
                  value: function running() { }
              }, {
                  key: "eating",
                  value: function eating() { }
              }], [{
                  key: "random",
                  value: function random() { }
              }]);
          }();
  ```

### 3.2class继承自extends源码

- ES6进行继承直接写 ！！记得super的用法

```
class Person{
            constructor(name,age){
                this.name = name
                this.age = age
            }
            running(){}

            static random(){}
        }
        class Student extends Person{
            constructor(name,age,sno){
                super(name,age)
                this.sno = sno
            }
            eating(){}
        }

        var stu1 = new Student()
```

- 使用ES5写源码很麻烦

  感觉就是让新创建的对象具有原来对象的性质，再将要建立的域新对象用原型产生联系

```js
"use strict";

function _instanceof(n, e) { return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](n) : n instanceof e; }

function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }

function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }

function _isNativeReflectConstruct() {
    try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })); }
    catch (t) { } return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })();
}


function _getPrototypeOf(t) { //获取原型
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t);
}

function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t, writable: !0, configurable: !0
        }
    }
    ),
        Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }

function _classCallCheck(a, n) {
    if (!_instanceof(a, n)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }

function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}

function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }

function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var Person = /*#__PURE__*/function () {
    function Person(name, age) {
        _classCallCheck(this, Person);
        this.name = name;
        this.age = age;
    }
    return _createClass(Person, [{
        key: "running",
        value: function running() { }
    }], [{
        key: "random",
        value: function random() { }
    }]);
}();
debugger
var Student = /*#__PURE__*/function (_Person) {//创建对象 更改原型 创建自己的属性
    function Student(name, age, sno) {
        var _this;
        _classCallCheck(this, Student);//防止类被当成普通函数直接调用 确保使用的是new就进行创建的
        _this = _callSuper(this, Student, [name, age]);
        _this.sno = sno;
        return _this;
    }
    _inherits(Student, _Person);
    return _createClass(Student, [{
        key: "eating",
        value: function eating() { }
    }]);
}(Person);
var stu1 = new Student();
```



## 思考

### 1.原型图中的各个关系

- 每个函数都有自己的prototype属性，除了Funtion.prototype.bind() ,该属性指向原型
- 每个对象有自己的`__proto__`属性，指向创建该构造函数的原型，指向[[prototype]]，只能通过`__proto__`进行访问
- 对象可以通过proto进行寻找不属于该对象的属性
- 对象的constructor指向函数 新建对象隐式原型指向原来对象的显式原型



- 用来初始化的对象就是构造函数，简单说就是new后面的
- 前面的就是实例对象
- constructor指向原型对象对应的构造函数
- ![image-20250509183006843](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250509183006843.png)
- 

### 2.编写ES6类实现继承 简单

### 3.使用babel进行ES6转换ES5的操作，并且阅读源码

真的逆天

### 4.说说对面向对象多态的理解

根本作用就是通过把过程化的条件语句转化成对象的多态性，减少这些条件分支语句

或者就是把不变的事和可能改变的事分离开来

```
function makeSound (animal) {  if (animal.sound instanceof Function) { // 判断是否有animal.sound且该属性为函数    animal.sound()  }}class Cat {  sound () {    console.log('喵喵喵～')  }}class Dog {  sound () {    console.log('汪汪汪！')  }}class Pig {  sound () {    console.log('啂妮妮')  }}makeSound(new Cat()) // '喵喵喵～'makeSound(new Dog()) // '汪汪汪！'makeSound(new Pig()) // '啂妮妮'
```

一个函数传入不同的类具有不同的表现形式

