## 一.迭代器

### 2.1什么是迭代器，创建迭代器

- 本身就是对象

- 实现next方法

  - 遍历完返回的是{done：false,value：value/undefined}
  - 看最后是否遍历结束

- 对于本身不能进行迭代的数据可以装上迭代器

- 创建迭代器

- ```js
  //迭代对象数组中的值
  const info = {
  	name : "huuyii",
  	age : 19,
  	friends : ["aaa","bbb","ccc"]
  	[Symbol.iterator](){
  		let index = 0
  		const infoIterator = {
  			next: () => {//为了让这个this能够绑定上面的对象，这里我们可以使用箭头函数不绑定this
  			//的特性，将这个做出优化
  				if(index < this.friends.length){
  					return {done:false,value:this.friends[index++]}
  				}else return {done:true}
  			}
  		}
  		return infoIterator
  	}
  }
  //迭代对象的keys/values的值
  const info = {
  	name : "huuyii",
  	age : 19,
  	friends : ["aaa","bbb","ccc"]
  	[Symbol.iterator](){
  		const entries = Object.entries(this)
  		let index = 0
  		const infoIterator = {
             if(index < entries.length){
                 	return {done:false,value:entries[index++]}
             }else return {done:true}
          }
          return infoIterator
  	}
  }
  //创建迭代器后后面就能进行迭代
  ```

  

### 2.2什么是可迭代对象（所有的都可以加上迭代器吗？）

- 具有函数：[Symbol.iterator]
- 返回：迭代器
- 满足可迭代协议，对象必须实现Symbol.iterator 有些对象是默认不可以迭代的比如普通对象和和函数，
- 但是我们可以通过加迭代器的方式，让他们可以进行迭代

### 2.3迭代器类型

- 数组/String/Map/argument/NodeList

### 2.4可迭代对象的特性

这些都是可以传入可迭代的对象

- Js的特殊语法：for of/spread syntax/yeild/j解构
- 构造函数方法传值 ：new Set（）
- 特殊的方法：Array.from()/Promise.all()...

### 2.5自定义类的可迭代对象

```js
        class Person{
            constructor(name,age,height,friends){
                this.name = name
                this.age = age
                this.height = height
                this.friends = friends
            }
            
            //添加实例方法。直接添加到对象原型上面
            [Symbol.iterator]() {
                let index = 0
                const iterator = {
                    next : ()=>{
                        if(index < this.friends.length){
                            return {done : false,value : this.friends[index ++]}
                        }else{
                            return {done : true}
                        }
                    }
                }
                return iterator
            }
        }
        const p1 =  new Person("huuyii",19,1.7,["huu","aaaa","nnn"])
        const p2 =  new Person("aaa",10,1.2,["bbb","vvv","ccc","lll"])

        //写完迭代器就可以进行迭代
        for (const friend of p2.friends) {
            console.log(friend)
        }
```

实现对类的迭代

### 2.6迭代器的中断执行

这里中断的时候我们也可以进行监听

一定掌握箭头函数的特性

```js
        class Person {
            constructor(name, age, height, friends) {
                this.name = name
                this.age = age
                this.height = height
                this.friends = friends
            }

            //添加实例方法。直接添加到对象原型上面
            [Symbol.iterator]() {
                let index = 0
                const iterator = {
                    next: () => {
                        if (index < this.friends.length) {
                            return { done: false, value: this.friends[index++] }
                        } else {
                            return { done: true }
                        }
                    },
                    //监听中断操作
                    return: () => {
                        console.log("监听到函数的中断")
                        return { done: true }
                    },
                }
                return iterator
            }
        }

        const p1 = new Person("huuyii", 19, 1.7, ["huu", "aaaa", "nnn"])
        const p2 = new Person("aaa", 10, 1.2, ["bbb", "vvv", "ccc", "lll"])

        //写完迭代器就可以进行迭代
        for (const friend of p2.friends) {
            console.log(friend)
            if (friend === "vvv") { //迭代器的中断
                break
            }
        }
        
```



## 二.生成器Generator

### 2.1生成器函数和生成器对象

- 生成器函数的特点

  - function*

  - 执行的时候返回生成器对象

  - 内部可以通过yield控制函数的进行

  - 需要使用生成器的next操作进行访问

  - ```js
            function* foo(){
                console.log("111")
                yield
                console.log("2")
                console.log("133")
                console.log("133")
                console.log("133")
                yield
                console.log("133")
                console.log("133")
                console.log("133")
                console.log("over")
            }
    	//！！函数返回生成器对象，自动生成Generator
            const generator = foo()
            // console.log(generator)
            generator.next()
            generator.next()
            generator.next()        
    ```

    

- 生成器对象：特殊的迭代器 放回的类型也是{done：,value:}

- 可以通过这个进行调用

### 2.2生成器的返回值和参数

- 生成器的返回值时迭代器对象{done,value}

- 再yeild后面增加的参数我们 可以使用这个值作为value进行返回

- 后面调用next的时候传入的参数，我们可以再**上一个**yield拿到 

  ```js
  const next = yield "aaa"
  ```

  

- ```js
          function* foo(name1){
              console.log("执行内部代码：111",name1)
              const name2 = yield "aaa" //能够作为value进行返回
              console.log("执行内部代码：2",name2)
              console.log("执行内部代码：133")
              console.log("133")
              console.log("133")
              const name3 = yield "bbb"
              console.log("133",name3)
              console.log("133")
              console.log("133")
              yield "bbb"
              console.log("over")
              return undefined //最后done：true
          }
          console.log(generator.next())
          console.log(generator.next("第二次调用next")) 
          console.log(generator.next("第三次调用next"))
          console.log(generator.next()) 
  
  ```

  

### 2.3提前结束return/throw

可以使用return提前结束

```js
console.log(generator.return("停止"))
```

这样就能停止运行返回{done:true,value:..} 直接结束

也可以使用throw进行停止

```js
console.log(generator.throw("停止"))
```

下面的函数不会执行直接就会报错，爆出异常

下面没有捕获异常的就会停止运行

### 2.4generator替代iterator

- createArray方法

  - ```js
    funtion* createArray(arr){
    	for(let i = 0;i<arr.length;i++) yield arr[i]
    }
    
    //语法糖
    funtion* createArray(arr){
    	yield* arr
    }
    ```

    

- createRange方法

  - ```js
            function* createRanger(start,end){
                for(let i = start;i<=end;i++){
                    yield i
                }
            }
    ```

    

- 语法

  - yield*

  - 在自定义类中的实现

    ```js
            class Person {
                constructor(name, age, height, friends) {
                    this.name = name
                    this.age = age
                    this.height = height
                    this.friends = friends
                }
    
                //添加实例方法。直接添加到对象原型上面
                //前面加上* 代表生成器函数 转化成生成器函数
                *[Symbol.iterator]() {
                    yield* this.friends  //直接加上想要进行迭代的对象的前面
                }
            }
    //直接使用yield返回迭代器的特性进行迭代
    ```

    

- 自定义类中的替代 

- 注意：我们自己拿symbol.iterator也可以进行迭代



## 思考

### 1.区分迭代器和可迭代对象

- 可迭代对象：
  - 实现了可迭代协议
  - 必须包含了Symbol.iterator方法，并且该方法返回一个迭代器
  - 定义了对象的迭代方式，使得对象能够使用迭代器的相关方法进行遍历
  - 常见的：array string set。。。。
- 迭代器：
  - 实现了迭代器协议的对象
  - 包含一个无参数的next（）方法，该方法返回value和done两个属性的对象
  - 作用：控制具体的迭代过程，跟踪迭代的状态
  - 数组调用Symbol.iterator返回的对象
- 迭代器不等于可迭代对象，只有当迭代器自身实现了symbol.iterator方法并且返回自身是，才是可迭代对象

### 2.什么是生成器（函数/对象），生成器和迭代器的关系

- 生成器：
  - 生成器函数:
    - 通过在funtion后面添加*来声明 可以通过yield暂停函数的执行并在后续恢复执行
    - 不会立即执行，会返回一个生成器对象，让下一次从停止的位置继续执行
  - 生成器对象：
    - 生成器函数调用后返回的对象
    - 实现迭代器协议（调用Symbol方法返回自身） 具备next方法 
- 关系：
  - 生成器是特殊的迭代器 能够给对象加上迭代器
  - 生成器更易构建迭代器



## 问题

### 1.如何判断一个对象是否可迭代

```js
obj[Symbol.iterator] === "funtion"
```

### 2.实现简单的自定义函数 从1迭代到3

```js
function myIterator = {
	current : 1,
	max : 3
	next : (){
		if(this,current <= this.max)return {done:false,value:this.current++}
		else return {done:true}
	}
}
```

### 3.生成器函数和中的yield和return的区别

yield用来暂停生成器函数执行并返回一个值，后续可以从暂停的地方继续执行

return 直接结束生成器函数并返回一个值之后再次调用yeild直接dong：true

### 4.使用生成器实现简单的异步函数

控制执行的步骤

```js
function* request(){
	 const res1 = yield requestDate("huuyii")
     console.log(res1)

     const res2 = yield requestDate(res1 + "aaa")
     console.log(res2)

     const res3 = yield requestDate(res2 + "bbb")
     console.log(res3)

     const res4 = yield requestDate(res3 + "ccc")
     console.log(res4)
}

function run(genFn){
	const genterator = genFn()
    function exec(res){
       const result = genreator.next(res)
       if(result.done)return
       result.value.then(res => {
           exec(res)
       })
    }
}

run(request)
```

