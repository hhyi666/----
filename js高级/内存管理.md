## 一.深入JS原理

### 3.1全局对象的创建

```js
<script>
        var message = "Global Message"
        
        function foo(){
            var message = "Foo Message"
            console.log(bar)
        }

        var num1 = 10
        var num2 = 20
        var res = num1 + num2
        console.log(res)
    </script>
```



### 3.2执行全局的代码

```js
<script>
        var message = "Global Message"
        
        function foo(){
            var message = "Foo Message"
            console.log(bar)
        }

        var num1 = 10
        var num2 = 20
        var res = num1 + num2
        console.log(res)
    </script>
```



### 3.3执行函数的代码

```js
 <script>
        var message = "Global Message"
        
        //函数会建立相应的对象
        //调用生成AO对象
        //函数执行完后会在上下文栈当中被弹出
        function bar(){
            console.log("bar")
            var address = "bar"
        }              
        
        //这些对象 age height 。。都会放在VO对象里面
        function foo(name){
            var age = 18
            var height = 1.22
            var message = "Foo Message"
            console.log(bar)
            bar()
        }
        
        foo(123)

        var num1 = 10
        var num2 = 20
        var res = num1 + num2
        console.log(res)

    </script>
```

VO：储存变量和函数的定义，不会进行赋值，只是创建定义

AO： 进入函数执行上下文时，VO别激活为AO，AO除了储存变量和函数的定义外，还会储存函数的参数

### 3.4作用域作用域链

```js
<script>
        // console.log(message)

        // var message = "Global Message"

        // function foo(){
        //     var message = "foo message"
        //     console.log(message)
            
        // }
        // foo()


        //！！函数的作用域链已经在定义的时候已经创建好了后面不会改变作用域链

        //作用域链是一个对象列表，用于变量标识符的求值
        //当进入一个上下文时 这个作用域链
        var message = "Global message"
        
        function foo(){
            console.log(message)//自己的作用域中没有对应的值 向上层查找
        }
        foo()

        var obj = {
            name : "obj",
            bar : function(){
                var message = "bar message"
                foo()
            }
        }
        obj.bar()//这里的message还是Global不会改变
    </script>
```

## 二.JS的内存管理

### 2.1内存管理的理解

- js中存在自动管理内存

- 生命周期
  - 分配申请需要的内存
  - 使用分配的内存
  - 不需要的时候，对其进行释放

### 2.2GC实现算法

- 标记清除算法
  - 可达性
  - 设置一个根对象，垃圾回收器会定期从这个跟对象开始，找到所有的有引用的对象，对于没有引用的对象，就认为是不可用的对象
- 引用计数
  - 有一个引用，对象的引用就加1
  - 当引用是0的时候，对象就可以被销毁
  - 弊端：可能会产生循环引用
- 标记整理
  - 将分散的空间汇集到连续的空间，从而整合空闲空间，避免内存碎片化
- 分代收集
  - 分成新的和旧的，新的检查频率高，旧的检查频率低
- 闲时收集
  - 在GPU空闲的时候尝试运行，减少可能对代码执行的影响

### 2.3闭包的概念

函数引用不是自己作用域中的变量

js所有的函数都可以是闭包的

### 2.4闭包的内存流程

！！！画图

进入执行上下文

在函数执行上下文的时候会创建一个AO对象来存放初始化的变量

创建GO对象 -> 记录自己的函数内容 -> 创建AO对象

### 2.5闭包的内存泄漏

```js
 <script>
        function createArray(){
            var arr = new Array(1024*1024).fill(100)

            function test(){
                console.log(arr)
            }
            return test//不进行返回，其他地方不会出现这样的话直接就清空内存了
            //形成闭包，不会进行回收
            //保证可以访问到外部的arr数组
        }
       var totalArray = []

        var createbtnEl = document.querySelector(".create")
        var destorybtnEl = document.querySelector(".destory")
        createbtnEl.onclick = function(){
            for(var i = 0;i<100;i++){
                totalArray.push(createArray())
            }
        }
        destorybtnEl.onclick = function(){
            totalArray = []//清空数组就可以清空内存
        }

    </script>
```

这里arr数组在函数中还在被引用，所以不能够被识别清除内存，函数中存在test函数+return

这里的arr数组还在被访问就无法清除就需要手动的进行清除，直接将需要清除的东西赋值为null就行

浏览器的优化：对于函数中定义的变量，但是没有进行访问，浏览器就会进行优化，直接清除

### 三.JS代码的执行流程

### 1.代码加载和全文执行上下文的创建

全局对象（VO）初始化 ： 函数的var声明和函数会进行变量提升，但是变量的赋值操作不会提升，函数声明会完整提升

```js
console.log(a); 
var a = 10;
function b() {
    console.log('This is function b');
}
b(); 
```

访问a就是undefined b可以直接使用

### 2.执行栈的初始化

（后进先出）用于管理执行上下文的创建和销毁，全局执行上下文会压入栈的底部，成为栈底元素

### 3.全局代码的执行

- 创建新的函数执行上下文
  - 活动对象（AO）的创建
  - 作用域链的构建
  - this指针的绑定
- 将新的函数执行上下文压入执行栈

### 4.函数代码的执行

### 四.V8引擎的内存管理以及垃圾回收器

### 1.内存分配

主要分为栈内存和堆内存

### 2.垃圾回收器

采用多种垃圾回收算法（GC）

## 五.闭包为什么会产生内存泄露以及如何解决

1. 内存泄漏的主要原因就是闭包中仍然持有对这些变量的引用
2. 仍然存在引用，是的无法触发垃圾回收机制

### 解决办法

1. 及时释放闭包引用

   将对应的数据设置成为null

2. 避免在闭包当中引用不必要的变量

3. 及时清理闭包

