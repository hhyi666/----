# 深拷贝和事件总线

## 一.深拷贝

- 引用赋值/浅拷贝/深拷贝的区别和关系

  | 特性     | 引用赋值  | 浅拷贝                                   | 深拷贝                                            |
  | -------- | --------- | ---------------------------------------- | ------------------------------------------------- |
  | 新对象   | 没有创建  | 创建新对象                               | 创建新对象                                        |
  | 基本类型 | 共享值    | 复制值                                   | 复制值                                            |
  | 引用类型 | 共享引用  | 共享引用                                 | 递归复制                                          |
  | 修改影响 | 相互影响  | 影响嵌套函数                             | 互不影响                                          |
  | 实现方式 | 直接赋值= | Object.assign()<br />使用扩展运算符(...) | JSON.prase(JSON.stringfy())<br />或者使用递归函数 |

  

- JSON实现深拷贝的问题

  新建对象使用函数进行 转码 和 解码的操作实现转变

  ```js
  const obj = JSON.prase(JSON.stringfy(info))
  ```

  弊端：

  - 无法处理特殊类型的对象 Symbol 函数 正则 会被直接忽略
  - Date对象 会转成字符串 失去特性
  - Map/Set数据结构会被完全丢弃
  - 若存在循环引用会导致错误、
  - 丢失属性配置 setter getter 不可枚举属性等
  - 无法处理自定义构造函数实例
  - 大数的精度丢失 

- 实现深拷贝

  - 基本实现

    ```js
    function deepCopy(obj){
    	if(!Object(obj)){
    		return obj
    	}
        //但是对象也有有可能是数组 或者 对象
    	const newObj = Array.isArray(obj)?[]:{}
    	for(const key in obj){
    		newObj[key] = deepCopy(obj[key])
    	}
    	return newObj
    }
    ```

    

  - Set

    ```js
    function deepCopy(obj){
    	if(!Object(obj)){
    		return obj
    	}
        
        //如果是set对象需要进行特殊的判断
        if(obj instanceof Set){
            const newSet = new Set()
            for(const value of set){
                newSet.add(deepcopy(value))
            }
            return newSet
        }
        //但是对象也有有可能是数组 或者 对象
    	const newObj = Array.isArray(obj)?[]:{}
    	for(const key in obj){
    		newObj[key] = deepCopy(obj[key])
    	}
    	return newObj
    }
    ```

    

  - 函数

    ```js
    function deepCopy(obj){
    	if(!Object(obj)){
    		return obj
    	}
        
        //如果是set对象需要进行特殊的判断
        if(obj instanceof Set){
            const newSet = new Set()
            for(const value of set){
                newSet.add(deepcopy(value))
            }
            return newSet
        }
        
        
        //如果是函数类型 直接返回就行
        if(typeof obj === "function"){
        	return obj
        }
        //但是对象也有有可能是数组 或者 对象
    	const newObj = Array.isArray(obj)?[]:{}
    	for(const key in obj){
    		newObj[key] = deepCopy(obj[key])
    	}
    	return newObj
    }
    ```

    

  - Symbol

    ```js
    function deepCopy(obj){
        //如果是symbol类型 返回新的symbol
        if(typeof obj === "symbol"){
            return Symbol.(obj.description)
        }
    	if(!Object(obj)){
    		return obj
    	}
        
        //如果是set对象需要进行特殊的判断
        if(obj instanceof Set){
            const newSet = new Set()
            for(const value of set){
                newSet.add(deepcopy(value))
            }
            return newSet
        }
        
        
        //如果是函数类型 直接返回就行
        if(typeof obj === "function"){
        	return obj
        }
        //但是对象也有有可能是数组 或者 对象
    	const newObj = Array.isArray(obj)?[]:{}
    	for(const key in obj){
    		newObj[key] = deepCopy(obj[key])
    	}
        
        //单纯遍历Symbol
        const symbolkeys = Object.getOwnPropertySymbols(obj)
        for(const element of symbols){
            newObj[element.description] = deepCopy(obj[element],map)
        }
    	return newObj
    }
    ```

    

    - key
    - value

  - 循环引用

    - WeakMap

      ```js
      function deepCopy(obj){
          //如果是symbol类型 返回新的symbol
          if(typeof obj === "symbol"){
              return Symbol.(obj.description)
          }
      	if(!Object(obj)){
      		return obj
      	}
          
          //如果是set对象需要进行特殊的判断
          if(obj instanceof Set){
              const newSet = new Set()
              for(const value of set){
                  newSet.add(deepcopy(value))
              }
              return newSet
          }
          
          
          //如果是函数类型 直接返回就行
          if(typeof obj === "function"){
          	return obj
          }
          //用来解决循环引用的问题 存储过就直接返回
          if(map.get(obj))return map.get(obj)
          //但是对象也有有可能是数组 或者 对象
      	const newObj = Array.isArray(obj)?[]:{}
          map.set(obj,newObj)
      	for(const key in obj){
      		newObj[key] = deepCopy(obj[key])
      	}
          
          //单纯遍历Symbol
          const symbolkeys = Object.getOwnPropertySymbols(obj)
          for(const element of symbols){
              newObj[element.description] = deepCopy(obj[element],map)
          }
      	return newObj
      }
      ```



## 二.时间总线

组件之间用来沟通的桥梁
可以向中心事件发送事件或接收事件  实现兄弟组件之间的数据通讯

- class HYEventBus

  ```js
          class HYEventBus{
              constructor(){
                  this.eventMap = {}
              }
  
  
              on(eventName,eventFn){ //表示进行监听
                  let eventFns = this.eventMap[eventName]
                  if(!eventFns){   //没有值就放一个空数组进去
                      eventFns = []
                      this.eventMap[eventName] = eventFns
                  }
                  eventFns.push(eventFn) //记得将值存下来
                  //赋值引用，直接更改就行
              }
  
              off(eventName,eventFn){//取消操作 
                  //找到对应的name中的Fn进行删除操作
                  let eventFns = this.eventMap[eventName]
                  if(!eventFns)return
                  for(let i = 0;i<eventFns.length;i++){
                      const fn = eventFns[i]
                      if(fn === eventFn){
                          eventFns.splice(i,1)
                          break
                      }
                  }
                  //没有监听就删除
                  if(eventFns.length === 0){
                      delete this.eventMap[eventName]
                  }
              }
              
              emit(eventName,...args){ //表示发送事件 函数在这里获取进行监听 
                  //能够接收到的函数就进行返回
                  let eventFns = this.eventMap[eventName]
                  if(!eventFns)return
                  eventFns.forEach(fn => {
                      fn(...args) //这样就能将参数传回去
                  })
              }
          }
  
  
          //类 Eventbus -> 事件总线
          //使用过程
          const eventBus = new HYEventBus()
  
  
          //nav.vue在组件中监听事件 表示谁进行监听
          eventBus.on("navclick",() => {
              console.log("navclick listener 01")
          })
          
          const click = () => {
              console.log("navclick listener 02")
          }
          setTimeout(() => {
              eventBus.off("navclick",click) //通过off进行清除
          }, 5000);
  
          eventBus.on("navclick",click)
  
  
          eventBus.on("siderclick",() => {
              console.log("siderclick listener 03")
          })
  2
  
          //nav.vue
          const btnEl = document.querySelector(".nav-btn")
          btnEl.onclick = function(){
              console.log("自己监听到按钮的点击")
              eventBus.emit("navclick","huuyii")
              //发送事件。上面的进行监听
          }
  ```

  

- 方法

  - on(eventName,eventFn) 监听
  - emit(eventName) 发送事件
  - off(eventName,eventFn) 取消事件